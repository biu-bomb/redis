# 使用场景

当一个集合全部是整数并且数量不多的时候，``Redis``使用整数集合作为集合键的底层实现。

# 结构定义

```c
typedef struct intset {
  uint32_t encoding;
  uint32_t length;
  int8_t contents[];
} intset;
```

| field        | description                                          |
| ------------ | ---------------------------------------------------- |
| ``contents`` | 具体存储的数组<br />长度为单元素长度和元素个数的乘积 |
| ``length``   | 存储元素的个数                                       |
| ``encoding`` | 不同``encoding``，占据``int8_t``长度不一致           |

<font color='red'>数组并非存储的直接元素，根式根据编码确定，不同格式元素占据不同位数的数组长度</font>

<font color='red'>数组元素：从小到大，有序不重复</font>

| encoding             | type      |
| -------------------- | --------- |
| ``INTSET_ENC_INT16`` | ``int16`` |
| ``INTSER_ENC_INT32`` | ``int32`` |
| ``INTSET_ENC_INT64`` | ``int64`` |

# 升级降级

不同类型的数据类型，占据数组不同大小；为了统一管理，``encoding``总是以最大的数据类型为准。

并且，也会将较小的元素格式修改为指定的``encoding``

## 触发时机

> <font color='red'>不支持降级操作</font>

| operation | condition                  |
| --------- | -------------------------- |
| 升级      | 新插入数据，且数据范围更大 |
| 降级      | 不支持降级                 |

## 具体操作

- 数组扩容
  $$
  \text{arr_len} = \text{data_size} \times \text{length}
  $$
  首先计算出所需的数组大小，并准备好空间

- 数据迁移

  按照从后到前的方式进行数据迁移，发生升级，每个元素所占的空间会对应的增大。

  迁移过程中根据元素大小确定长度，并且完成数据移动

## 操作优势

- 提升灵活性

  ``c``是静态语言，对于不同的元素类型通常使用不同的容器进行存储。

  而整数集合采用底层自动升级的方式，自适应调整元素类型。

  我们可以任意的将``int16_t``,``int32_t``,``int64_t``数据进行添加而不必担心出现类型错误。

- 节约内存

  如果采用``int64_t``的数组，可以直接存储``int16_t``和``int32_t``的数据，但是势必造成内存浪费。

  自适应的进行格式调整，不仅能够容纳数据，在数据低于``int64_t``的场景下，有效避免空间浪费。

# 整数集合のAPI

| method            | description | O           |
| ----------------- | ----------- | ----------- |
| ``intsetNew``     | 创建        | $O(1)$      |
| ``intsetAdd``     | 添加        | $O(N)$      |
| ``intsetRemove``  | 移除        | $O(N)$      |
| ``intsetFind``    | 存在        | $O(\log N)$ |
| ``intsetRandom``  | 随机        | $O(1)$      |
| ``intsetGet``     | 查询        | $O(1)$      |
| ``intsetLen``     | 元素个数    | $O(1)$      |
| ``intsetBlobLen`` | 字节长度    | $O(1)$      |

