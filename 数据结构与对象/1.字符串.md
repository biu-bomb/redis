# 结构定义(SDS)

```c
// sds.h/sdshddr
struct sdshdr{
  int len;
  int free;
  char buf[]; // total-length = len + free + 1
}
```

| field    | description |
| -------- | ----------- |
| ``len``  | 字符串长度  |
| ``free`` | 剩余空间    |
| ``buf``  | 字符空间    |

# 结构优势

## 复用部分字符串API

基础的字符串表示方法，同样是

- 使用字符数组进行存储
- 使用`\0`表示结尾

当我们使用``SDS``定义的结构的时候，并没有带来更大的差异，顶层关于字符串的``API``能够部分复用。

---

但是，在其他方面它带来了更多的便利

## 直接获取字符串长度

基础的字符串，仅存储了字符串自身的内容，长度信息需要遍历一遍字符数组才能够得知，时间复杂度为$O(n)$。

``SDS``在设置的时候，直接设置了``len``，因此需要获取长度的时候，直接查询就可以获取，时间复杂度为$O(1)$。

##  杜绝缓冲区溢出

字符串都是使用字符数组进行存储的，对字符串进行拼接的时候，需要将后半的字符拷贝到前面的数组当中。

但是基础的字符串没有长度属性，这个时候就会出现两种场景

- 对前面的字符数组进行检查，判断剩余空间是否能够容纳后续字符，然后再进行操作
- 直接拼接字符，如果后续长度大于剩余空间，就会数组越界，越界复制造成缓冲区溢出

核心问题还是在对长度的获取，``SDS``的长度可直接获取，封装以后判断扩容，直接屏蔽溢出问题。

## 减少内存重分配次数

如果字符数组严格的按照字符串长度分配空间，每次字符串的增长都会涉及字符数组的内存重新分配。

因此，``SDS``使用冗余空间进行存储，当不超过字符数组长度的时候，直接拼接就可以。

---

- ==``SDS``的冗余策略==

| part     | description                                                  |
| -------- | ------------------------------------------------------------ |
| ``len``  | ``len``始终是字符串长度                                      |
| ``free`` | $\left\{\begin{matrix}\text{len} & \text{len} < 1M \\ 1M &\text{len} \ge 1M\end{matrix}\right.$ |

## 惰性空间释放

字符串变长的时候，需要重新申请内存分配；字符串变短的时候，同样需要回收空闲空间。

基础字符串的变化操作，引发操作系统频繁地申请和回收。

---

``SDS``字符串截断的时候，会自动的更新``len``和``free``，并不会立即去进行内存回收，具体信息还是存储在了``free``中。

- 如果面临字符串拼接，很大程度能够避开内存申请
- 后续需要回收，具体的数值也能够直接进行获取

## 二进制安全

虽然同样是<font color='red'>字符串</font>，但是``SDS``实质上是``buf[0:len]``。

基础的字符串，有一些严格的格式要求，就比如``\0``必然不能作为字符串内容，不可能直接的表达二进制数据。

``SDS``本质就是字符数组，并且底层的字符编码确定，这里的字符数组可以等价为字节数组，没有任何的额外要求。

因此，``SDS``可以存储任意的二进制数据，基础的字符串数据结构只是``SDS``的一个子集。

# ``SDSのAPI``

| method          | description              | $O$        |
| --------------- | ------------------------ | ---------- |
| ``sdsnew``      | 创建(字符串)             | $O(N)$     |
| ``sdsempty``    | 创建                     | $O(1)$     |
| ``sdsfree``     | 释放                     | $O('free)$ |
| ``sdslen``      | ``len``                  | $O(1)$     |
| ``sdsavail``    | ``free``                 | $O(1)$     |
| ``sdsdup``      | ``copy``                 | $O(len)$   |
| ``sdsclear``    | 清空数组                 | $O(1)$     |
| ``sdscat``      | 拼接字符串               | $O(N)$     |
| ``sdscatsds``   | 拼接``sds``              | $O(N)$     |
| ``sdscpy``      | 重新设置内容字符串       | $O(N)$     |
| ``sdsgrowzero`` | 使用空字符扩展到指定长度 | $O(N)$     |
| ``sdsrange``    | 清空非区间内字符         | $O(N)$     |
| ``sdstrim``     | 移除指定字符串中的字符   | $O(N^2)$   |
| ``sdscmp``      | 比对两个``SDS``          | $O(N)$     |

# 总结

| ``C``                                    | ``SDS``                         |
| ---------------------------------------- | ------------------------------- |
| 获取字符串长度$O(n)$                     | 获取字符串长度$O(1)$            |
| ``API``不安全，可能造成缓冲区溢出        | ``API``安全，不会造成缓冲区溢出 |
| 修改字符串长度$N$次，必定$N$次内存重分配 | 修改$N$次，最多$N$次重分配      |
| 只能保存文本数据                         | 文本和二进制                    |
| 全部``<string.h>``函数                   | 部分``<string.h>``              |

